<!DOCTYPE html>
<html>
<head>
  <title>manzikert.ca</title>
  <style>
body     { display:flex; flex-direction:column; align-items:center;
           font-size:1rem; margin:min(10vw,100px) auto; }
pre      { max-width:min(80ch,80vw); margin:auto; white-space:pre-wrap; }
.code    { max-width:80vw; word-break:break-all; }
.white   { color:#444444; }
.red     { color:#ff0000; }
.green   { color:#00aa00; }
.hgreen  { color:#008800; }
.blue    { color:#0000ff; }
.yellow  { color:#ddaa00; }
.magenta { color:#ff00ff; }
.cyan    { color:#00cccc; }
  </style>
</head>
<body><div>
<pre class='code'>
clpz:monotonic.

instruction((right,N)) --&gt; "R", number(N).
instruction((left, N)) --&gt; "L", number(N_), { #N #= - #N_ }.
input(I) :- phrase_from_file(sequence(instruction,"\n",I), "i/01.in").

box(right,N,Box) :- #Box #= #N div 100.
box(left, N,Box) :- #N_ #= #N - 1, #Box #= #N_ div 100.
turn((Dir,N),(Dial0,P1_0,P2_0),(Dial1,P1_1,P2_1)) :- 
	#Dial1 #= #Dial0 + #N, if_(clpz_t(#Dial1 mod 100 #= 0), #P1_1 #= #P1_0 + 1, #P1_1 #= #P1_0),
	box(Dir, Dial0, Box1), box(Dir, Dial1, Box2), #P2_1 #= #P2_0 + abs(#Box1 - #Box2).

solve(P1,P2) :- input(I), foldl(turn,I,(50,0,0),(_,P1,P2)).
test         :- make_test(day(1),solve,1158,6860).
</pre><pre>


Well, this was certainly harder than your average day 1. I use a DCG to parse the input, then use a left fold to simulate turning the dial and keeping track of zeros.

For part two, I imagine that each multiple of 100 is in its own "box". For example, -5 is in box -1, and 123 is in box 1. If you turn from -5 to 123, you cross from box -1 -&gt; box 0 -&gt; box 1, so you pass over two 0s. The only tricky thing is that you need to define boxes differently for turning left/right to get this to work.
</pre>
<br>
<pre style='width:100%;text-align:center'><br><a href='/'>~</a>/<a href='./'>aoc25pl</a>/<a href='01'>01</a></pre>
</div></body>
</html>
